# LED MATRIX

- - - - - -
## Introduction
- - - - - -

### I2C protocol

I2C (pronounced i squared c or i two c) is a serial computer bus
and data communication protocol, invented by Philips Semiconductor.

It's typically used for attaching low-speed peripheral Integrated Circuits
to processors and microcontrollers in short-distances, such as intra-board communication.

The phillips I2C protocol defines the concept of master and slave devices.
A master device is one that is in charge of the bus at the present time
and controls the clock and generates START and STOP signals.
Slaves simply listen to the bus and act on controls and data that they are sent.

The master can send data to a slave or receive data from a slave - slaves
do not transfer data between themselves.

The I2C interface uses two bi-directional lines, i.e. either device could "drive" either line.
these lines are SDA for data, and SCL for clock.


I2C basic command sequence (master writes to slave)

01. Send the START bit (S). (done by master)
02. Send the slave address (ADDR). (done by master)
03. Send the Write(W)-0 bit. (done by master)
04. Wait for an acknowledge bit (A). (done by master)
05. Send acknowledge bit (A). (done by slave)
06. Receive an acknowledge bit (A). (done by master)
07. Send the data byte (8 bits) (DATA). (done by master)
08. Send acknowledge bit (A). (done by slave)
09. Receive an acknowledge bit (A). (done by master)
10. Send the STOP bit (P).

I2C basic command sequence (master reads from slave)

01. Send the START bit (S). (done by master)
02. Send the slave address (ADDR). (done by master)
03. Send the Read(R)-1 bit. (done by master)
04. Wait for an acknowledge bit (A). (done by master)
05. Send acknowledge bit (A). (done by slave)
06. Receive an acknowledge bit (A). (done by master)
07. Receive the data byte (8 bits) (DATA). (done by master)
08. Send acknowledge bit (A). (done by master)
09. Receive an acknowledge bit (A). (done by slave)
10. Send the STOP bit (P).

In both cases, steps 7 through 9 can be repeated n times before master sends the stop bit (P).

The acknowledge bit (A) means that the data transfer was successful, so if it's not received,
the device that sent the data can try to send it again.

The Start bit (S) can only be generated by a master device, and it means that SCL is in a logic one
and that SDA is falling from a logic one (or is in a "falling edge")

The Stop bit (P) can only be generated by a master device, and it means that SCL is in a logic one
and that SDA is rising from a logic zero (or is in a "rising edge")

When a slave receives a start bit (S) it resets its internal bus logic.

A slow slave device may need to stop the bus while it gathers data.
It can do this by holding the clock line (SCL) low ,forcing
the master into a wait state. The master must then wait until SCL is released
before proceeding. This can be done because the lines are "open drain"
i.e. if one device holds a line low, the other cannot try to put it into high.

The I2C standard is very attractive to manufacturers, because of its simplicity and ease of use
but requires royalties, so some
manufacturers say that their devices "use a 2 wire interface", and thus avoid
explicitly using the term I2C and having to pay royalties.

I2C may be used with VGA, DVI and HDMI ports, because they are a superset of the I2C
connectionts pinout, i.e. they include an SDA, SCL, ground (GND) and +5VDC pins, all
the necessary pins/connection lines for I2C communication.


### Hardware Drivers

Device drivers take on a special role in the Linux kernel. They are distinct “black
boxes” that make a particular piece of hardware respond to a well-defined internal
programming interface; they hide completely the details of how the device works.
User activities are performed by means of a set of standardized calls that are indepen-
dent of the specific driver; mapping those calls to device-specific operations that act
on real hardware is then the role of the device driver. This programming interface is
such that drivers can be built separately from the rest of the kernel and “plugged in”
at runtime when needed. This modularity makes Linux drivers relatively easy to write,
to the point that there are now hundreds of them available. [1]

To implement a driver for a character device, it must be programmed in the C programming
language, as a module for the kernel, and a special Makfile with the assignment for

```
obj-m
```
which uses the kernel build system, and not the "vainilla" make build process.

A few important things to keep in mind are:
*   floating point numbers are not used in kernel programming
*   testing kernel modules can be dangerous, so extreme caution is adviced, using a "sacrificial" computer to test modules on is a common practice
*   the linux kernel changes very rapidly, so programming a module for one version may not work in the next, so it is recommended to build against the kernel version of interest, or to continually update the module should the device driver API change


### The LED MATRIX Project

This project consists in developing a driver for the Linux kernel, to use an
HT16K33 controlled LED backpack (by adafruit), as a file, and call it from a
library (programmed in the C programming language) that is used by a web
application to send text and some other symbols (namely, some emoji) to display
them in the LED matrix.


- - - - - -
## Technical Specifications
- - - - - -

### Driver

The driver was programmed in the C programming language, as it is the standard
when programming device drivers, it's the most well documented, it's the
most familiar to the ones involed in the development of the project, and it
was required as an assingment for a course on Operating System Principles.

The Tools used in the development of the driver include the GNU Compiler
Collection's C language compiler, `gcc` for compiling the source code,
Sublime Text as a text editor, GNU Make to automate the build process, Git
for source version control, SSH to connect to the target machine,
and the Bourne Again Shell (bash) as a shell.


### Library

The library was programmed in the C programming language, as it is the most
familiar and comfortable to the ones involved in the development of the
project, not to mention, it's very efficient in use of resources, and very
fast to execute, which are important points in embedded device programming.

The tools used in the development of the library include the GNU Compiler
Collection's C language compiler, `gcc` for compiling the source code,
Vi IMproved (Vim) as a text editor, GNU Make to automate the build process,
Git for source version control, SSH to connect to the development machine,
ack to search the source code once it reached a few hundred lines,
ZSH as a shell, and The Terminal Multplexer (Tmux) to manage several virtual
terminal emulators to run Git, SSH. Vim, ack, and Make simultaneously.


### Web Application

The web application was programmed in HTML, JavaScript, and JQuery, with
Twitter's Bootstrap to make the application work with both desktop and mobile
web browsers, because of both a lack of familiarity with PHP, which was the
required language in the assignment, as well as familiarity with Javascript,
JQuery, Bootstrap, and Node.js.

It makes use of an emoji picker library in order to provide to the user an
easy way to use the avaliable emoji set.

- - - - - -
## Program Design
- - - - - -

### Inner Workings and Examples

The server provides an user friendly web interface for the user to write a message, select the desired emoji from the emoji picker and finnaly process and send the string to the server. The message is passed as a parameter to the wrapper, it is processed using the library and then displayed through the LED Matrix by writting values to the files created in the device tree when the driver is loaded in the system. 



### Communication between Components

The Web interface communicates with the server by using Web API methods to send the message entered by the user in JSON format. This is easly developed with Express in the server side and JQuery in the client side.

The message is get by the server from the JSON response and then it is passed as a parameter of the wrapper. 

- - - - - -
## Use Instructions
- - - - - -

### Requirements
NodeJS 6.11 or newer.
npm in order to install dependencies. 


### Set Up



### How To



- - - - - -
## Activities Log
- - - - - -



- - - - - -
## State of the Project
- - - - - -

### Final state of Development (as of 2017-06-16)



### Challenges faced on Development



- - - - - -
## Conclusions and Recommendations
- - - - - -



- - - - - -
## References
- - - - - -

[1] Jonathan Corbet, Alessandro Rubini, and Greg Kroah-Hartman "Linux Device Drivers, 3rd ed."
